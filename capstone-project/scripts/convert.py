# -*- coding: utf-8 -*-
"""capstone-project.ipynb

Automatically generated by Colab.
"""

import torch
import torchvision.models as models
# from torchvision import transforms
import torch.nn as nn

import onnx
import onnxscript

path = './mobilenet_result_10_0.983.pth'

class BloodClassifierMobileNet(nn.Module):
    # def __init__(self, size_inner=100, droprate=0.2, num_classes=5):
    # def __init__(self, droprate=0.2, num_classes=5):
    def __init__(self, num_classes=5):
        super(BloodClassifierMobileNet, self).__init__()

        self.base_model = models.mobilenet_v2(weights='IMAGENET1K_V1')

        for param in self.base_model.parameters():
            param.requires_grad = False

        self.base_model.classifier = nn.Identity()

        self.global_avg_pooling = nn.AdaptiveAvgPool2d((1, 1))
        # self.inner = nn.Linear(1280, size_inner)  # New inner layer
        self.relu = nn.ReLU()
        # self.dropout = nn.Dropout(droprate)  # Add dropout
        # self.output_layer = nn.Linear(size_inner, num_classes)
        self.output_layer = nn.Linear(1280, num_classes)

    def forward(self, x):
        x = self.base_model.features(x)
        x = self.global_avg_pooling(x)
        x = torch.flatten(x, 1)
        # x = self.inner(x)
        x = self.relu(x)
        # x = self.dropout(x)  # Apply dropout
        x = self.output_layer(x)
        return x

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = BloodClassifierMobileNet(num_classes=5)
model.load_state_dict(torch.load(path))
model.to(device)
model.eval()

# x = val_transforms(img)
# batch_t = torch.unsqueeze(x, 0).to(device)

# # Make prediction
# with torch.no_grad():
#     output = model(batch_t)

# train_dataset.class_to_idx

# classes = [
#     "basophil",
#     "erythroblast",
#     "monocyte",
#     "myeloblast",
#     "seg_neutrophil"
# ]

# dict(zip(classes, output[0].to('cpu')))

# # 'basophil' class has the highest value - this is correct prediction

# # Checking of trained model with the image from test part of dataset

# from PIL import Image
# import numpy as np

# # Load an image from test part of the prepared dataset
# img_test = Image.open('blood-cell-images-for-cancer-detection-prepared/test/myeloblast/MYO_0700.jpg')

# # Resize to target size
# img_test = img_test.resize((224, 224))

# x = val_transforms(img_test)
# batch_t = torch.unsqueeze(x, 0).to(device)

# # Make prediction
# with torch.no_grad():
#     output = model(batch_t)

# dict(zip(classes, output[0].to('cpu')))

# # 'myeloblast' class has the highest value - this is correct for the test image, prediction of the high risk of cancer by AML indicators

# Create dummy input
dummy_input = torch.randn(1, 3, 224, 224).to(device)

# Export to ONNX
onnx_path = "blood_classifier_mobilenet_result.onnx"

torch.onnx.export(
    model,
    dummy_input,
    onnx_path,
    verbose=True,
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={
        'input': {0: 'batch_size'},
        'output': {0: 'batch_size'}
    },
    external_data=False # used to compose .onnx and .onnx.data files into single file
)

print(f"Model exported to {onnx_path}")